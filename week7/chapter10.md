## 대입 연산자의 오버로딩

### 01. 대입연산자와 복사생성자
  - **객체간 대입연산 : 대입 연산자로 이루어 진다. (즉, 함수의 연산인 것이다!)**
    - 객체 초기화 시에 값을 넣을 때는 복사생성자가 호출되지만, 객체 초기화 이후 값을 대입할 때는 대입연산자, 즉 함수가 사용된다!
  - 대입연산자의 특징
    - **복사생성자의 특징과 유사하다.**
    - 따로 선언하지 않으면, 디폴트 대입연산자가 호출된다.
    - 따로 선언하지 않으면, 얕은 복사가 진행된다.
    - 동적할당된 멤버간의 대입연산 시에 깊은 복사가 필요하면 깊은 복사가 가능하도록 따로 정의해야 한다!
    - **값의 대입은 등호가 여러번 쓰인 경우, 맨 오른쪽에서 왼쪽으로 진행된다.**
```cpp
class AAA{ ... };

AAA obj1(..);
AAA obj2, obj3;

obj2 = obj3 = obj1;
// obj1에서 obj3로 복사되고, 그 다음 obj3에서 obj2로 복사된다!
```

## 02. 대입연산자의 문제점과 해결책
  - 2가지 문제가 발생한다.
    - **원래 있던 메모리 위치를 가리키는 값을 잃어서 메모리 누수 발생, 동일 메모리 주소를 가리키는 얇은 복사가 중복 소멸의 문제를 일으킨다.**
    - 복사생성자는 초기화 단계에서 할당하는 것이기에 원래 존재하던 값이 없어서 메모리 누수는 일어나지 않는데, 대입연산자에선 일어난다.
  - 해결방법
    - 깊은 복사가 가능하게끔 대입연산자의 내용을 수정해준다. : 중복 소멸의 문제 해결
    - 원래 있던 메모리를 해제하고 다시 메모리 공간을 할당한다 : 메모리 누수 문제 해결
```cpp
class Person{
private:
  int age;
  char *name;
public:
  // 생성자
  Person(...)
  
  Person & operator=(const Person &ref){
    // 먼저 원래 할당됬던 공간을 제거 - 메모리 누수 문제 해결
    delete []name;
    
    // 그리고 깊은 복사를 진행. ref가 원본, 해당 객체가 사본
    age = ref.age;
    int len = strlen(ref.name) + 1;
    name = new char[len];
    strcpy_s(name, len, ref.name); // strcpy_s는 vs에서 지원하는 strcpy..
    
    // 사본 해당 객체를 반환하여 다중 대입연산 대비.
    return *this;
    
  }
  // 다중으로 대입연산이 이뤄질 수 있으므로, 참조자를 반환 (ex. per1 = per2 = per3 ...)
  // per1.operator=(per2)의 의미이므로, ref의 값이 복사의 원본이다.
  // const Person& ref를 통하여 (const 선언), ref 값의 방지를 막는다.
}
```

## 03. 대입연산자의 상속에서의 문제점과 해결책
  - **유도 클래스의 디폴트 대입연산자는 자동으로 기초 클래스의 대입연산자를 호출한다.**
  - 유도 클래스의 디폴트 아닌 대입연산자에서 기초 클래스의 대입연산자를 호출하지 않은 경우, 기초 클래스 멤버의 대입이 안일어난다.
    - **유도 클래스의 대입연산자를 사용자가 정의해야하는 경우, 기초 클래스의 대입연산자 또한 같이 호출해주어야 한다!*
```cpp

```
  
  
  
  
  
  
  
  
  
  