# 복사 생성자

## 1. 복사생성자
 - 객체의 복사를 돕는 생성자.
 - 같은 class 틀을 공유한다면 객체를 복사해서 다른 객체에 그대로 찍어넣을 수 있다.
```cpp
soSimple sim1 = sim2;
soSimple sim2(sim2);
```

## 2. 생성자 관점에서의 복사 생성자
 - 복사 생성자를 굳이 추가하지 않더라도, 디폴트 복사 생성자가 자동으로 삽입된다.
 - 추가한다면, 생성자의 매개변수를 & 참조자로 선언해주어야한다. -> 그렇지 않으면 무한루프에 빠진다.
 
## 3. 복사 생성자의 배제
 - 복사 생성자를 배제하려면 explicit을 사용하면 된다.
```cpp
SoSimple {
  explicit SoSimple(SoSimple &copy)
     : num1(copy.num1) , num2(copy.num2) {} 
     // num1, num2는 SoSimple 객체의 private 멤버변수인데, 복사 시에 그냥 '.'으로 접근할 수 있는 것 같다!
};
```
## 4.0 얕은 복사와 깊은 복사
 - **얕은 복사**는 복사된 객체가 힙영역의 메모리 공간을 참조할 때, 동일한 메모리 공간을 공유하게 된다.
 - **깊은 복사**는 마찬가지 상황에서, 새로 메모리 공간을 만들고, 새로운 객체가 그 공간을 참조하게 된다.
 
## 4.1 얕은 복사의 문제와 해결
 - **문제**
  - **객체 소멸때**, 사본 객체의 소멸과정에서 **원본 객체의 메모리 또한 소멸**되기에, **원본 객체 메모리 소멸 과정에서 문제**가 생긴다.
 - **해결**
  - **깊은 복사**를 통해 복사 시에 메모리 공간 자체를 새로 만들어 주면 해결 가능.
  - 깊은 복사를 구현하는 방법은 **복사된 녀석에게도 새로운 힙영역 메모리를 부여**해줘서 메모리 삭제시 문제 발생 예방
```cpp
class Person{
private:
  char *name;
  int age;
public:
  Person(Person & per) :age(per.age){
    name = new char[strlen(per.name)+1];  // 객체 복사 시에 아예 새로운 공간을 할당해 버리는 것.
    strcpy(name, per.name);               // 새로 할당된 공간에 값을 넣어버림.
  }
  ~Person(){
    delete []name;                        // 나중에 삭제할 때도 문제 발생하지 않음.
  }
};
```
