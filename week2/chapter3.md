## 1. 참조자 매개변수 선언과 포인터 매개변수 선언 헷갈리지 않기
  - 참조자 매개변수 ( 읽기 전용 )
```cpp
function( const int &p );
```  
  - 포인터 매개변수
```cpp
function( int *p );
```

## 2. c의 라이브러리에 있던 함수들의 cpp에서의 사용.
   - .h를 빼고 앞에 c를 붙이면 된다!
```cpp   
<stdio.h> : <cstdio>
<math.h> : <cmath>
```   
   - C의 표준에 정의된 함수들은 namespace std에 포함되어 있기에, using namespace std; 를 명시해주어야만 한다.
   - cpp는 함수오버로딩(매개변수의 자료형, 갯수 다르면 다른 함수)을 제공하기에, 더 개선된 형태로 사용할 수 있다. (그러므로 cpp의 표준헤더를 가급적 이용하자)

## 3. cin 관련

### 3.1 동적할당된 포인터 문자열 입력받기.
```cpp
char *ptr = new chr[];
cin >> ptr; // ( cin >> *ptr (X) )
```

### 3.2 한줄 전체 입력받기.
```cpp
#include <iostream>
#include <string>
int main(void){
  string str;
  getline(cin, str);   // getline( iostream객체 , string 변수 이름); <- 문자열 공백 포함받기.
  return 0;
}
```

## 4 구조체

### 4.1 구조체는 연관되는 data를 묶어서 구현, 관리하기 용이하게 만들어준다.

### 4.2.0 구조체 변수 선언
```cpp
struct struct_name real_name; // struct 구조체이름 객체이름
struct_name real_name;        // 구조체이름 객체이름

// struct Car car;
// Car car;
```

### 4.2.1 구조체와 class의 초기화
```cpp
structEx{ , , };  // struct는 {} 안에 멤버들의 값을 넣는다.
classEx();        // class는 () 안에 멤버들의 값을 넣는다.
```

### 4.3.0 구조체 안에 함수 넣기
  - 구조체는 어떠 데이터 덩어리의 집단인데 그 **데이터 집단을 처리하는 함수**는 **그 부류들과 관계**를 맺는다. 
  - 그러한 함수들이 엉뚱하게 전역에 들어가 있으면 호출 오류를 발생시킬 수도 있다
  - 그러므로, **함수를 구조체 안에 넣는 시도**가 등장했다.+ cpp에서는 구조체 안에 함수를 넣는 것을 허용한다.
  - **함수를 구조체 안에 넣으면..**
    - **참조자 매개변수를 받지 않아도 된다.**
    - 그에 **종속된 모든 변수 설정들이 필요 없어**진다. 구조체 내의 변수들에 직접접근이 가능해졌기 때문이다.

### 4.3.1 구조체 밖으로 함수 빼기
  - 구조체를 봤을 때 기능이 한눈에 들어오는 것이 가장 좋은 것
  - 깔끔하게 정리하는 방법 : **함수의 원형선언은 구조체 안에** 두고, **함수의 정의를 구조체 밖으로** 빼는 것. (빼낸 함수의 정의는 namespace 개념을 활용한다.) 
  - 구조체 내부의 함수는 inline 함수로 처리된다.

### 4.4.0 구조체 안에 enum 넣기
  - 특정 구조체와의 관계에서만 의미를 갖는 enum 또한 구조체 안에 넣으면 좋다.
```cpp
struct Car{
  enum{
    ID_LEN = 20, MAX_SPD = 200, FUEL_STEP = 2 ,,,
}
```

### 4.4.1 구조체 밖 namespace로 enum 빼기
  - 혹은 namespace를 지정하여 상수가 사용되는 영역 명시하는 것도 방법이다.
```cpp
namespace CAR_CONST{
  enum{
    ID_LEN = 20, MAX_SPD = 200, FUEL_STEP = 2 ,,,
}
```

## 5 class

### 5.1 구조체와 class가 다른점 : class는 내부 요소들에 대한 접근을 제어할 수 있다.
  - 접근제어지시자 : **public** **protected** **private**
    - **public** : **어디서든** 접근 가능
    - **private** : **내부 함수들의 접근만** 허용
    - **protected** : **상속과 관련**
  - 별조 접근 제어 지시자가 없다면
    - struct 내부 요소들은 전부 public 선언
    - class 내부 요소들은 전부 private 선언
  - 정의를 밖으로 빼도, 접근제어지시자의 영향을 받는다.

### 5.2 객체, 멤버변수, 멤버함수
  - **객체**  
    - class 틀을 가지고 찍어낸 것
    - **객체지향 프로그래밍**은 현실에 존재하는 **대상과 현상을**, 있는 그대로 **실체화 시키는 형태의 프로그래밍**이다.      
  - 멤버변수 : class 내의 변수
  - 멤버함수 : class 내의 함수

### 5.3 class, 파일분할
  - .h 헤더파일에는 class 관련 선언을 집어넣는다.
    - class와 **관련된 변수들도 namespace를 지정해서 넣어줄 수 있다.**
  - .cpp에는 헤더파일 속 class의 정의를 집어넣는다.
    - **무조건 선언이 들어있는 .h 헤더파일을 선언 해줘야**한다.
    - 또한 **class의 정의를 할 땐 namespace 한정을 해줘야 한다.**
```cpp
#include "head.h"           // head.h 헤더 선언 요구
void SomeClass::foo(){      // 정의 시에 class이름:: 으로 namespace 한정요구
    // function 내용
}
```
  - inline 함수를 사용할 때는 .h 헤더파일 안에 넣어주어야 한다.
    - 컴파일러는 **서로 다른 cpp 파일을 동시에 컴파일해서 실행파일을 만든다 하더라도**, **한 cpp파일을 컴파일할 때, 다른 cpp파일의 내용을 참조하지는 않는다.**

### 5.4 class, 객체만들기
  - class 틀 만들기
    - 대상을 구성하는 요소들을 정의한다.
    - 요소들을 멤버변수, 멤버함수로 구체화 한다.
      - **상태정보**는 **멤버변수**로 정의
        - 변하지 않는 값은 const로 정의한다.
        - const는 생성과 동시에 초기화되어야만 한다!  // 생성자
      - **행동정보**는 **멤버함수**로 정의
  - class 객체화 시키기
    - 일반적 변수 선언
    - 포인터 변수 선언
```cpp
ClassName objName;      // 일반변수 선언
ClassName * objName_2;  // 포인터변수 선언
```

### 5.5 객체간 메시지 전달
  - 객체간 메시지 전달은 함수호출을 기반으로 이뤄진다.

---------------------------------------------------------------------------

## 단일문자가 서로 같은지 비교할 때.
 - char c에 문자를 입력받았다면..
   - if( c== 'w') 처럼 '(char type)' 비교
   - char c 에서 string c 로 바꾸고 if(c=="w") 처럼 "(char type)"과 비교.


---------------------------------------------------------------------------

## 답할 수 있어야 한다.

### 1. 헤더파일의 역할이 무엇인가?
  - 다른 파일들에 대한 선언을 가지고 있다.
    (일반적으로 선언만 포함함)
  - 메뉴판에 비유하곤 하는 것 같다.
  
### 2. 헤더파일에 들어가야할 내용이 무엇인가?
  - 함수의 선언 부분과 중복 방지 부분이다.
  
### 3. 헤더파일의 중복포함을 막을때 쓰는 #ifndef ~ #endif는 무엇인가?
  - 함수가 두번 이상 포함되는 문제를 해결하기 위하여 중복 포함을 막는 것이다.
  - #pragma once 또한 같은 역할을 한다.
  - #ifndef와 #endif 사이에 있는 내용이 이전에 등장한적있다면 컴파일에서 생략한다.

### 4. 둘이상의 파일을 컴파일해서 하나의 실행파일을 만들 수 있는가?
  - main이 있는 파일에 헤더파일들을 추가해준다.
  
### 5. 링커가 하는 일이 무엇인가?
  - **서로 다른 obj 파일을 하나의 실행파일로 묶어준다.**
  - 컴파일, 링크, 컴파일러
     - **컴파일** : 원시파일.cpp을 목적파일.obj로 바꿔준다.
     - **링크** : 목적파일.obj을 실행파일.exe로 바꿔준다. 
     - **컴파일러** : 원시파일.cpp에서 실행파일.exe을 생성하는 일련의 과정을 진행시켜준다.




